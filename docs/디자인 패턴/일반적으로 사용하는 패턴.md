# 일반적으로 사용하는 패턴
이번에는 일반적으로 사용하는 패턴 세 가지를 설명한다. 순서대로 [Decorator Pattern(데커레이터 패턴)](#q-데커레이터-패턴의-예를-설명할-수-있는가)
, [Flyweight Pattern(플라이 웨이트 패턴)](#q-플라이웨이트-패턴의-구현-방법을-설명할-수-있는가)
, [Sington Pattern(싱글턴 패턴)](#q-싱글턴-패턴은-어떻게-사용하는가)
으로 설명하며, 특히 싱글턴은 면접 질문으로 가장 흔하게 등장하므로 필히 익혀두면 좋겠다.
예제 패턴 살펴보기와 마찬가지로 각 패턴을 어떻게 구현하는지, 어떤 상황에서 사용하는지, 어떤 문제를 해결할 수 있는지를 중점적으로 살펴보겠다.

### Q. 데커레이터 패턴의 예를 설명할 수 있는가?

### Q. 플라이웨이트 패턴의 구현 방법을 설명할 수 있는가?

### Q. 싱글턴 패턴은 어떻게 사용하는가?
마지막으로 서두에 강조했던 싱글턴 패턴이다. 특징으로는 오직 하나의 인스턴스만 생성한다. 그럼 언제 필요할까?
어떤 스레드에서든 동일한 객체를 관리하고 싶을 때, 추가로 객체를 생성하지 않고 바로 사용하고 싶은 경우에 유용하다.

요즘에는 Joda-time에 밀려 잘 사용되지 않지만, Calender 객체는 대표적인 싱글턴 패턴의 객체다. 날짜나 시간은 어느 객체에서나 동일한 정보를 원하기 때문에 이만큼 잘 어울리는 디자인 패턴도 없다. 하지만 사용할 때 마다 메모리에 인스턴스를 생성하기에 날짜처리 함수들이 가볍지 않아 무분별하게 생성할 수도 없다. 따라서 **하나의 객체를 생성해 동일한 데이터를 모두 사용할 수 있도록 구현하였다.**

이제 왜 필요한지 이해했으니 직접 구현해보자. 구현은 크게 메모리에 올리는 시점에 따라 두 가지로 나누어 진행할 것이다.

먼저 런타임 시점에 메모리에 올리는 방법이다.

```{.java}
public class Main {
    public static void main(String[] args) {
        MySingleton singleton = MySingleton.getInstance();
        MySingleton singleton2 = MySingleton.getInstance();
        System.out.println(singleton); // 두 객체는 동일한 주소값을 반환한다.
        System.out.println(singleton2);
    }
}
class MySingleton {
    // 모든 객체에서 사용하는 클래스 변수(런타임 시점에 이미 메모리에 올라간다.)
    private static MySingleton MYSINGLETON = new MySingleton();

    // 여러 객체를 생성할 수 없도록 private하게 생성자 선언
    private MySingleton(){}

    // 유일한 객체를 리턴
    public static MySingleton getInstance(){
        return MYSINGLETON;
    }

    // 클래스변수를 통해 이하 기능들을 수행
    public String getTest(){
        return "Test code";
    }
}
```

해당 방법은 간편함이 장점이지만, 싱글턴 객체가 무거운데 자주사용되지 않으면 불필요하게 큰 메모리공간을 차지하게 된다. 자주 사용하는 객체라는 확신이 있을 때만 사용하기에 적합하다.

다음은 호출하는 시점에 객체를 생성하는 방법이다. 흔히 'Lazy initialization(지연된 초기화)' 라고 부르는 방법이다.
```{.java}
... 생략

class MySingleton {
    private static MySingleton MYSINGLETON;

    private MySingleton(){}

    public static MySingleton getInstance(){
        // 호출 시점에 생성
        if (MYSINGLETON == null) {
            MYSINGLETON = new MySingleton();
        }
        return MYSINGLETON;
    }

    public String getTest(){
        return "Test code";
    }
}
```
getInstance 메서드를 보면 클래스변수가 null인 경우에 생성한다. 런타임 시점에 메모리에 올라가지 않으므로 성능적으로 좋은 방법이다. 그러나 아직 문제가 남아있다. 
```{.java}
public class Main {
    public static void main(String[] args) {
        Thread th1 = new Thread(() -> {
            System.out.println(MySingleton.getInstance().toString());
        });
        Thread th2 = new Thread(() -> {
            System.out.println(MySingleton.getInstance().toString());
        });

        // 멀티스레드 환경에서 싱글턴이 유지될까?
        th1.start();
        th2.start();
    }
}
class MySingleton {
    private static MySingleton MYSINGLETON;

    private MySingleton(){}

    public static MySingleton getInstance(){
        // 호출 시점에 생성
        if (MYSINGLETON == null) {
            try {
                Thread.sleep(100L);// 객체의 볼륨이 커 생성하는데 100m/s의 시간이 걸린다고 가정하자.
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            MYSINGLETON = new MySingleton();
        }
        return MYSINGLETON;
    }

    public String getTest(){
        return "Test code";
    }
}
```
위와 같은 멀티스레드 환경에서는 싱글턴 본연의 롤인 '단일객체' 원칙이 깨진다. 객체를 생성하는 100m/s의 시간동안 다른 스레드에서 호출하면서 또 한번 객체가 생성되기 때문이다. 이제는 Thread-safety한 싱글턴을 만들기 위해 두 가지 방법을 확인해보겠다. 우선 synchronized 키워드를 활용한 방법이다.

```{.java}
... 생략

class MySingleton {
    private static MySingleton MYSINGLETON;

    private MySingleton(){}

    // synchronized 키워드 사용
    synchronized public static MySingleton getInstance(){
        // 호출 시점에 생성
        if (MYSINGLETON == null) {
            try {
                Thread.sleep(3000L);// 이번엔 무려 3000m/s의 시간이 걸린다고 가정하자.
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            MYSINGLETON = new MySingleton();
        }
        return MYSINGLETON;
    }

    public String getTest(){
        return "Test code";
    }
}
```
synchronized 키워드를 사용할 경우, 싱글턴 객체를 동기화하여 thread-safety한 프로그래밍을 할 수 있다. 하지만 해당 방법도 문제가 없는 것은 아니다. *최초 객체를 생성할 때는 꿀같던 동기화가 만들어진 객체를 호출할 때는 **모든 스레드의 요청이 병목**되어 프로그램 성능을 저하시킬 수 있기 때문이다.* 따라서 마지막으로 보여질 방법은 생성시점 요청에는 동기화를, 호출 시점 요청에는 비동기화를 지원하도록 설계한 싱글턴방법이다.

```{.java}
... 생략

class MySingleton {
    // volatile 키워드 사용
    private volatile static MySingleton MYSINGLETON;

    private MySingleton(){}

    public static MySingleton getInstance(){
        // 호출 시점에 생성
        if (MYSINGLETON == null) {
            try {
                Thread.sleep(3000L);// 이전과 동일하게 3000m/s의 시간이 걸린다고 가정하자.
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (MySingleton.class) {
                if (MYSINGLETON == null) {
                    MYSINGLETON = new MySingleton();
                }
            }
        }
        return MYSINGLETON;
    }

    public String getTest(){
        return "Test code";
    }
}
```
핵심은 **getInstance 메서드가 더이상 동기화 메서드가 아니라는 점이다.** 따라서 생성의 요청이든, 호출의 요청이든 해당 메서드는 비동기 형태로 처리한다. 다만 생성의 호출일때는 synchronized 블록을 통해 동기화 하여 생성한다는 점이 앞선 방법과 큰 차이점이다. volatile 키워드는 간단하게 'CPU 캐시로부터 값을 읽는 것이 아니라, 메모리에서 읽는다' 라고만 설명하고 추가적인 내용은 아래 참조링크를 통해 읽어보길 바란다.

**[등장배경]**

오직 하나의 인스턴스만 생성하여 관리해야할 경우, 메모리 낭비와 어떤 요청에서도 동일한 값을 제공하기 위해 고안되었다. 대표적인 예로는 Calender 객체가 있다.

**[장점]**
- 메모리에 하나의 인스턴스만 존재하므로 성능상의 이점이 있다.
- 관리포인트가 하나이므로 쉽게 관리 및 설정할 수 있다.
- 어떤 요청이 와도 동일한 값을 제공할 수 있다.

**[단점]**
- 구현은 간단하나 멀티스레드 환경에서 고려할 사항이 많다.
- 사용자는 단일객체임을 믿고 사용하므로, 두개 이상의 객체가 생성 될 시 예측불가능한 오류가 발생한다.
- 편리한 만큼 싱글턴 객체에 모든 연산을 밀집시키면 득보다 실이 더 커진다.
- 병목현상의 원인이 될 수 있으므로 자주 사용하는 기능은 별도의 객체로 분리하는 것이 옳다.

**[구현방법]**
1. 객체의 내부에 본인을 대상 클래스를 담을 클래스 변수를 생성한다.
2. 생성자는 private을 사용하여 외부에서 생성을 막는다.
3. getInstance 메서드를 통해 클래스 변수만을 리턴한다.

### 참고

[Java Volatile 의미](http://thswave.github.io/java/2015/03/08/java-volatile.html)
