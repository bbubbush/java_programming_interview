# 어노테이션 이용하기

책에서는 어느테이션에 대한 기술보다 앞서 질문을 독자에게 던진다. 이 글을 읽는 분들은 이미 어노테이션이 무엇인지 모르진 않을 것이다. 그래도 용어를 명확히 짚고 넘어감으로써 서로간의 혼란과 이해의 차이를 줄여보고자 한다.

>어노테이션은 메타데이터에 일종으로, 자바 소스코드에 추가하여 사용할 수 있다. 보통 @기호를 앞에 붙여서 사용하며 JDK1.5 이상부터 지원한다.

즉, 자바의 메타데이터의 역할을 하며 JDK1.5 이상에서 소스코드에 추가하여 사용할 수 있는 방법이라고 할 수 있다. 이런 개념을 가지고 지금부터 책에 나온 면접질문을 하나씩 확인해보자.

### Q. 어노테이션을 사용하는 예를 들어라.

책에서는 JUnit의 @Test 어노테이션을 중심으로 설명하지만 자바, 특히 스프링을 쓰면서 다양하게 봤을 것이다.

MVC에 해당하는 @Controller, @Service, @Autowired 들과 트랜잭션 관리를 위한 @Transactional 도 있다. Lombok 라이브러리를 쓰면 @Data, @Getter, @Setter, @Builder 등 도 자주 접하게 된다.

이렇게 사용하는 예는 너무너무 많다. 그래서 이번 질문을 조금 바꿔 '어노테이션의 종류를 분류해보자.' 로 바꿔서 해보겠다.

크게 어노테이션은 [Built-In(빌트인)](#빌트인-어노테이션), [Meta(메타)](#메타-어노테이션), [Custom(사용자)](#사용자-어노테이션) 세 가지로 나눈다.

##### 빌트인 어노테이션

자바 SDK에 내장되어 제공 되는 어노테이션을 말한다. 대표적인 어노테이션 몇개만 알아보자.

@Override : 현재 메서드가 수퍼클래스의 메서드를 오버라이드함을 명시한다. 만약 오버라이드 메서드가 아니라면 컴파일 에러가 난다.

@Deprecated : 더이상 사용되지 않는 메서드에 사용한다. 해당 메서드를 사용하려 하면 컴파일 경고를 발생시킨다.

@SuppressWarnings : 선언한 영역의 컴파일 경고를 무시한다. 개인적으로는 사용을 권하지 않지만, [어떤 블로그](https://medium.com/@hyeonhomartinkang/suppresswarnings-활용-a9493c0c3f82) 글을 읽고 나서 '상황에 따라 잘 쓰는 것도 방법이겠다' 싶었다.

##### 메타 어노테이션

어노테이션을 생성할 때 사용되며, 어노테이션을 위한 어노테이션이라고 할 수 있다. 아래에서 보게 될 @Retention, @Target 등이 메타 어노테이션이다. 위 두 어노테이션은 다음 질문에서 설명하니 여기서는 생략하겠다.

@Documented : 해당 어노테이션를 사용하는 대상은 javadoc으로 문서화 될 때, 어노테이션에 대한 설명도 포함하도록 한다.

@Inherited : 해당 어노테이션으로 만든 사용자 어노테이션 @Custom이 있다. @Custom을 사용하는 클래스가 수퍼클래스가 되면, 하위 클래스도 @Custom 어노테이션 속성을 공유하게 된다.

##### 사용자 어노테이션

메타 어노테이션을 활용하여 사용자가 직접 만드는 어노테이션을 총칭한다. 광의의 개념으로 빌트인, 메타 어노테이션을 제외한 모든 어노테이션이라 할 수 있다. 

**결론 : 어노테이션을 사용하는 예는 무궁무진하다. 따라서 이를 설명하기보다, 어떤 방식으로 어노테이션이 동작하는지 이해하고 설명하는 것이 더 중요하다고 생각한다.**

### Q. @Override 어노테이션은 어떤 역할을 하는가?

오버라이드 어노테이션이 어떻게 생겼는지 다들 아실 것 같지만, 눈으로 함께 확인하는 것이 좋겠다.

```java
@Override  // <- 바로 이것이다.
public int hashCode() {
	return super.hashCode();
}
```

해당 어노테이션이 붙은 메서드가 슈퍼클래스의 메서드를 오버라이딩 해야만 컴파일 오류 없이 동작한다. <u>만약 메서드 시그니처나 이름이 달라져 오버라이딩이 되지 않는다면, **컴파일 오류가 발생**한다.</u>

즉, 질문의 답으로써 **객체의 상속(구현) 간, 오버라이드 과정에서 실수가 일어나는 것을 방지해준다.** 잘못된 오버라이드를 할 경우 컴파일 오류를 내기 때문이다.

질문에 대한 충분한 답은 된 것 같지만 그럼 어떤 방식으로 확인을 하는 것일까? @Override 어노테이션을 살펴보자.

```java
// @Override 어노테이션
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.SOURCE)
public @interface Override {
}
```

구조는 간단하지만 @Target, @Retention 이라는 새로운 어노테이션이 보인다. 어노테이션을 공부하기 위해서 다른 어노테이션을 공부해야하다니... 그래도 생각보다 어렵지 않으니 이참에 알아보자.

> @Target : 어노테이션을 적용할 위치를 결정합니다.
>
> @Retention : 어노테이션의 영향이 미치는 시점을 결정합니다.

@Target을 먼저 보면, Enum값으로 "METHOD"를 받는 것을 보니 아마 메서드에만 적용할 것 같다. 실제로 오버라이드는 메서드의 관계 혹은 특징을 나타내는 방법이니 적합한 타겟으로 생각된다. 확인차 클래스나 필드값, 지역변수 등에 붙여보니 오류가 난다.

두번째로 @Retention 이다. Enum이 "SOURCE"인 것으로 보니 소스를 작성할 때만 영향을 줄 것 같습니다. 안타깝게도 정말로 소스작성 시점에만 영향을 주는지 검증할 방법이 떠오르지 않는다.(컴파일러를 속여 바이트코드를 작성하는 방법이 필요하다.)

**결론 : 따라서 위 두 가지 정보를 종합해볼때, <u>@Override 어노테이션은 메서드에만 붙일 수 있고, 소스를 작성할 때 까지만 유효하다.</u>** 

실제로 @MyOverride 어노테이션을 만들어 런타임 시점까지 유지해보고 싶었으나, @Override 어노테이션은 빌트인 어노테이션이라 동일하게 작성해도 같은 기능을 수행할 수 없다. 아래 참고한 사이트를 보면서 본인이 직접 어노테이션을 작성해보고, 적용하는 것 까지 해보길 바란다.

P.S @Target, @Retention 어노테이션의 값을 생각을 통해 가정하며 진행했으니, 구글링을 통해 꼭!! 명확하게 확인해야한다. 가정만으로 넘기기엔 프로그래밍은 녹록치 않다 : ( 

#### 참고

[Hyenho Martin Kang - @SuppressWarnings 활용](https://medium.com/@hyeonhomartinkang/suppresswarnings-활용-a9493c0c3f82)

[JDM's Blog - 자바 어노테이션](https://jdm.kr/blog/216)