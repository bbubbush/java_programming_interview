# 예외 처리하기

### Q. 자바의 예외 처리 구조를 이루는 주요 클래스를 설명하라.
![Exception 구조](./Exception_structure.png)
위 그림은 자바의 예외처리 구조를 간단히 도식화 한 것이다.

최상위 클래스는 Throwable 클래스며 그 아래 Exception(익셉션, 예외)과 Error(에러)로 분리된다. **익셉션**은 프로그래머가 예측 가능한 오류라 하고, **에러**는 프로그래머의 예측을 벗어난 오류이다. 대게 익셉션은 발생에 대응할 수 있는 방법이 존재하지만, 에러는 발생에 대해 대응하기 어렵다. 따라서 익셉션에 대해서 조금 더 자세히 보자.

그림을 보면 익셉션이 크게 Checked Exception(확인해야하는 예외)과 Unchecked Exception(확인 할 수 없는 예외)으로 구분된다. 사실 이 둘은 진짜 클래스가 존재하는 것이 아니라, 개념상의 분류라고 생각하면 좋다. Exceptin 하위 클래스 중 RuntimeException만 언체크드 익셉션으로 분류되고, 다른 클래스 모두 체크드 익셉션으로 분류한다. 

>RuntimeException의 예 : NullPointerException
>
>CheckedException의 예 : IOException

두 익셉션의 차이는 아래의 질문들을 통해 차근차근 설명하겠다.

### Q. '런타임 예외'와 '확인해야 하는 예외' 중 어느 것이 더 좋은가?

위에서 언지했듯 런타임 익셉션을 제외한 것은 모두 체크드 익셉션이다. 질문 자체가 둘 중 어느 것이 좋은지 물어보는 것이다. 이제부터는 지극히 주관적인 의견을 쓰겠다.

개인적으로는 체크드 익셉션을 좋아한다. 내가 이 객체를 사용할 때, 발생할 수 있는 문제에 대해 알려주는, 개발한 사람의 배려가 느껴지기 때문이다. 다만 예외처리의 책임을 전가한다는 점에서 코드가 길어질 여지가 생긴다.  아래 Class.java가 가지고 있는 forName() 메서드를 보자.

```java
@CallerSensitive
public static Class<?> forName(String className) throws ClassNotFoundException {
  Class<?> caller = Reflection.getCallerClass();
  return forName0(className, true, ClassLoader.getClassLoader(caller), caller);
}
...
  
// Class.forName()을 사용해보자.
public class Main {
    public static void main(String[] args) {
        try {
            Class.forName("HasClass");
        } catch (ClassNotFoundException e) {
            e.printStackTrace();
        }
    }
}
```



만약 Class.forName()을 사용하려고 한다면 컴파일 에러가 나면서 ClassNotFoundException을 처리하라고 할 것이다. 때문에 main()메서드는 throws로 ClassNotFoundException을 던지든, try ~ catch문을 통해 감싸든 둘 중 하나의 방법으로 처리해야할 책임이 생긴다. 

따라서 필자는 <u>해당 클래스의 이름을 못찾을 경우에 대해 대비</u>할 수 있지만, <u>처리를 의무로 해야하기 때문에 소스코드가 길어지고 복잡해진다.</u>

### Q. 연쇄 예외란 무엇인가?

하나의 상황을 가정하며 생각해보자.

> '예외처리를 위해 만든 catch블록에서 예외가 발생한다면 이것은 어떻게 생각해야할까?'





### Q. try-with-resources 문은 무엇인가?

JDK7 부터 도입된 새로운 try - catch 문법이다. try문 옆에 괄호가 생기면서 그 안에 리소스 객체를 전달하면 try블록이 끝나면 자동으로 자원을 종료시켜준다. *단, try에 전달되는 자원은 AutoCloseable인터페이스의 구현체여야 한다.*

사용 예를 살펴보자.

```java
public class Main {
    public static void main(String[] args) {
        try(FileReader reader = new FileReader("documents")){
            System.out.println(reader.read());  
            // try를 벗어나면 자동으로 reader 객체를 종료시킨다.
        }
        catch (FileNotFoundException e) {
            System.out.println("파일 경로를 못찾음");
        } catch (IOException e) {
            System.out.println("어떤 예외가 발생");
        }
    }
}
```

try문을 보자. 파일 리더를 리소스 객체로 사용한다. 파일 경로를 못찾는 경우와 다른 IOException이 발생했을 경우를 분리해야할 때, try-catch-finally 만으로 처리할 수 있을까?

그럼 try-with-resources 문법 이전의 방식을 보자.

```java
public class Main {
    public static void main(String[] args) {
        FileReader reader = null;
        try{
            reader = new FileReader("documents");
            System.out.println(reader.read());
        }
        catch (FileNotFoundException e) {
            System.out.println("파일 경로를 못찾음");
        } catch (IOException e) {
            System.out.println("어떤 예외가 발생");
        }
        finally {
            try {
                reader.close();
            } catch (IOException e) {
                System.out.println("reader 객체를 종료하다 오류가 날 수 있지");
            }
        }
    }
}
```

JDBC로 데이터베이스를 연결하는 작업을 했었다면, 이 지옥을 기억하실 것이다. try-catch-finally/try-catch 라는 일종의 패턴이 되어버린 이 구조... **이런 비효율을 막고자 try-with-resources 문법이 등장했다.**