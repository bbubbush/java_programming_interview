# JUnit 사용의 좋은 예



### Q. 테스트가 성공인지 어떻게 증명할 수 있는가?

테스트의 결과를 확인하기 위해 JUnit은 몇가지 정적 메서드를 지원한다.

- assertEqueals : 두 객체의 equals 메서드 값이 같은지 비교한다.
- assertTrue & assertFalse : 주어진 상태를 각 Boolean 값과 비교한다. 
- assertNotNull : 객체가 Not null인지 확인한다.
- assertArrayEquals : 두 배열에 같은 값이 있는지 확인한다. 

위 메서드를 활용해서 개발자는 테스트의 예상되는 결과를 실제 결과와 비교하면 된다. 예를 들어 null이 아닌 어떤 결과가 예상되는 메서드는 assertNotNull(member) 처럼 결과를 예측한다.

위에 기록한 테스트 정적 메서드들은 기본적으로 입력받는 파라미터들 앞에 String 파라미터를 추가할 경우, 실패시 메세지를 설정할 수 있다. assertNotNull("This is null.", member)  처럼 말이다. 이렇게 메세지를 활용하면 테스트가 실패해도 상대방에게 어떤 문제가 있었는지 나타낼 수 있다. 물론 시간이 촉박한 상황에서는 생략해도 괜찮다.



### Q. 어떻게 특정 예외를 예상할 수 있는가?

@Test 어노테이션에 expected 속성을 통해 특정한 예외에 대한 처리를 강제할 수 있다. '이 테스트에서 이 예외는 발생해야 한다' 는 의미를 내포한다고 볼 수 있다. 실제로 예외가 발생하지 않으면 테스트를 실패하게 된다. 간단한 테스트 코드로 확인해보자.

```java
@Test(expected = NullPointerException.class)
public void exceptionTest () {
  Member member = null;
  member.getId(); // NPE이 발생하므로 테스트는 성공
}
```

null 객체에 접근하니 NPE가 발생하고 @Test 어노테이션에 따라 테스트는 성공하게 된다. 사실 문법은 배우면 된다. 중요한 것은 언제, 어떤 상황에 사용하는 것인지 파악하는 것이다.

책에서는 코드의 의도나 명확성을 근거로 한 줄 정도의 코드에만 사용하는 등 명료한 방법으로 사용하길 권장한다. 개인적으로는 그보다 expected 자체에 태생이 과연 필요한가 의문이 든다. 테스트 코드는 개발자가 의도한 대로 결과가 나오는 것이 중요하다. 만약 예외가 발생하는 것을 의도했다면 그 코드는 예외처리가 되어야 하는 것이 정상이다. 하고싶은 말은 즉, <u>expected로 기대되는 예외는 코드 내에 예외처리를 통해 해결할 수 있다.</u> 

책에서는 expected를 사용하지 않고 try - catch 구문으로 동일한 효과를 내는 코딩스타일을 제공한다. 하지만 풀어내는 방법과는 별개로 다른 사용자에게 왜 이런 테스트가 필요한지 명확하게 설명하는 주석을 다는 것이 더 효과적이라고 생각한다. 기본적으로 테스트 코드의 성공은 정상적으로 흘러간다는 가정하에 작성하기 때문이다. 따라서 성공한 테스트코드 간에 어떤 테스트는 예외가 발생하서 성공이고, 어떤 테스트는 예외 처리가 잘 되어서 성공이라면 혼란이 발생할 소지가 있다.

### Q. 테스트가 예상했던 시간 안에 완료되지 않으면 테스트가 실패하게 만들 수 있는가?



### Q. RunWith 어노테이션은 어떻게 작동하는가?



### Q. 실행 중인 테스트들을 사용자화하려면 어떻게 해야 하는가?

